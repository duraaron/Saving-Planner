"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/scripts/genabi.mjs. This script parses the 
  <root>/backend/deployments directory to retrieve 
  deployment information for SavingPlanner.sol:
  
  - <root>/frontend/abi/SavingPlannerABI.ts
  - <root>/frontend/abi/SavingPlannerAddresses.ts
*/
import { SavingPlannerAddresses } from "@/abi/SavingPlannerAddresses";
import { SavingPlannerABI } from "@/abi/SavingPlannerABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type SavingPlannerInfoType = {
  abi: typeof SavingPlannerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves SavingPlanner contract metadata for the given EVM `chainId`.
 */
function getSavingPlannerByChainId(
  chainId: number | undefined
): SavingPlannerInfoType {
  if (!chainId) {
    return { abi: SavingPlannerABI.abi };
  }

  const entry =
    SavingPlannerAddresses[chainId.toString() as keyof typeof SavingPlannerAddresses];

  if (!("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: SavingPlannerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: SavingPlannerABI.abi,
  };
}

export type SavingsData = {
  target: number;
  rate: number; // in basis points (e.g., 500 = 5%)
  time: number; // in months
  currentSaving: number;
};

export type DecryptedResults = {
  target?: bigint;
  rate?: bigint;
  time?: bigint;
  currentSaving?: bigint;
  requiredSaving?: bigint;
  achievability?: bigint;
};

export const useSavingPlanner = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  const [targetHandle, setTargetHandle] = useState<string | undefined>(undefined);
  const [rateHandle, setRateHandle] = useState<string | undefined>(undefined);
  const [timeHandle, setTimeHandle] = useState<string | undefined>(undefined);
  const [currentSavingHandle, setCurrentSavingHandle] = useState<string | undefined>(undefined);
  const [requiredSavingHandle, setRequiredSavingHandle] = useState<string | undefined>(undefined);
  const [achievabilityHandle, setAchievabilityHandle] = useState<string | undefined>(undefined);

  const [decryptedResults, setDecryptedResults] = useState<DecryptedResults>({});
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const savingPlannerRef = useRef<SavingPlannerInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isSubmittingRef = useRef<boolean>(isSubmitting);
  const isDecryptingRef = useRef<boolean>(isDecrypting);

  const savingPlanner = useMemo(() => {
    const c = getSavingPlannerByChainId(chainId);
    savingPlannerRef.current = c;
    if (chainId && !c.address) {
      setMessage(`SavingPlanner deployment not found for chainId=${chainId}.`);
    } else {
      setMessage("");
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!savingPlanner) {
      return undefined;
    }
    return (Boolean(savingPlanner.address) && savingPlanner.address !== ethers.ZeroAddress);
  }, [savingPlanner]);

  const canSubmit = useMemo(() => {
    return (
      savingPlanner.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [savingPlanner.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const canDecrypt = useMemo(() => {
    return (
      savingPlanner.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      (requiredSavingHandle || achievabilityHandle) &&
      requiredSavingHandle !== ethers.ZeroHash &&
      achievabilityHandle !== ethers.ZeroHash
    );
  }, [
    savingPlanner.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    requiredSavingHandle,
    achievabilityHandle,
  ]);

  const refreshData = useCallback(() => {
    console.log("[useSavingPlanner] call refreshData()");
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !savingPlannerRef.current ||
      !savingPlannerRef.current?.chainId ||
      !savingPlannerRef.current?.address ||
      !ethersReadonlyProvider
    ) {
      setTargetHandle(undefined);
      setRateHandle(undefined);
      setTimeHandle(undefined);
      setCurrentSavingHandle(undefined);
      setRequiredSavingHandle(undefined);
      setAchievabilityHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);

    const thisChainId = savingPlannerRef.current.chainId;
    const thisAddress = savingPlannerRef.current.address;

    const contract = new ethers.Contract(
      thisAddress,
      savingPlannerRef.current.abi,
      ethersReadonlyProvider
    );

    Promise.all([
      contract.getRequiredSaving(ethersSigner?.address || ethers.ZeroAddress),
      contract.getAchievability(ethersSigner?.address || ethers.ZeroAddress),
    ])
      .then(([requiredSaving, achievability]) => {
        console.log("[useSavingPlanner] getRequiredSaving()=" + requiredSaving);
        console.log("[useSavingPlanner] getAchievability()=" + achievability);
        if (
          sameChain.current(thisChainId) &&
          thisAddress === savingPlannerRef.current?.address
        ) {
          setRequiredSavingHandle(requiredSaving);
          setAchievabilityHandle(achievability);
        }
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      })
      .catch((e) => {
        setMessage("SavingPlanner.getRequiredSaving() or getAchievability() call failed! error=" + e);
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner?.address, sameChain]);

  useEffect(() => {
    refreshData();
  }, [refreshData]);

  const submitSavingsPlan = useCallback(
    (data: SavingsData) => {
      if (isRefreshingRef.current || isSubmittingRef.current) {
        return;
      }

      if (!savingPlanner.address || !instance || !ethersSigner) {
        return;
      }

      const thisChainId = chainId;
      const thisAddress = savingPlanner.address;
      const thisEthersSigner = ethersSigner;
      const thisContract = new ethers.Contract(
        thisAddress,
        savingPlanner.abi,
        thisEthersSigner
      );

      isSubmittingRef.current = true;
      setIsSubmitting(true);
      setMessage("Starting encryption and submission...");

      const run = async () => {
        await new Promise((resolve) => setTimeout(resolve, 100));

        const isStale = () =>
          thisAddress !== savingPlannerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const input = instance.createEncryptedInput(
            thisAddress,
            thisEthersSigner.address
          );
          input.add32(data.target);
          input.add32(data.rate);
          input.add32(data.time);
          input.add32(data.currentSaving);

          setMessage("Encrypting data...");
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Ignore submission");
            return;
          }

          setMessage("Submitting to contract...");

          // Convert UI inputs to clear params required by contract:
          // - annualRateScaled6 = rate (basis points) * 100 (e.g., 500 -> 50000)
          // - months = time (already in months)
          const annualRateScaled6: number = Math.round(Number(data.rate) * 100);
          const months: number = Number(data.time);

          const tx: ethers.TransactionResponse = await thisContract.submitSavingsPlan(
            enc.handles[0], // target
            enc.handles[1], // rate
            enc.handles[2], // time
            enc.handles[3], // currentSaving
            enc.inputProof,
            annualRateScaled6,
            months
          );

          setMessage(`Wait for tx:${tx.hash}...`);

          const receipt = await tx.wait();

          setMessage(`Submission completed status=${receipt?.status}`);

          if (isStale()) {
            setMessage("Ignore submission");
            return;
          }

          refreshData();
        } catch (e) {
          setMessage(`Submission failed! Error: ${e}`);
        } finally {
          isSubmittingRef.current = false;
          setIsSubmitting(false);
        }
      };

      run();
    },
    [
      ethersSigner,
      savingPlanner.address,
      savingPlanner.abi,
      instance,
      chainId,
      refreshData,
      sameChain,
      sameSigner,
    ]
  );

  const decryptResults = useCallback(() => {
    if (isRefreshingRef.current || isDecryptingRef.current) {
      return;
    }

    if (!savingPlanner.address || !instance || !ethersSigner) {
      return;
    }

    if (!requiredSavingHandle && !achievabilityHandle) {
      setDecryptedResults({});
      return;
    }

    const thisChainId = chainId;
    const thisAddress = savingPlanner.address;
    const thisRequiredSavingHandle = requiredSavingHandle;
    const thisAchievabilityHandle = achievabilityHandle;
    const thisEthersSigner = ethersSigner;

    isDecryptingRef.current = true;
    setIsDecrypting(true);
    setMessage("Start decrypt...");

    const run = async () => {
      const isStale = () =>
        thisAddress !== savingPlannerRef.current?.address ||
        !sameChain.current(thisChainId) ||
        !sameSigner.current(thisEthersSigner);

      try {
        const sig: FhevmDecryptionSignature | null =
          await FhevmDecryptionSignature.loadOrSign(
            instance,
            [savingPlanner.address as `0x${string}`],
            ethersSigner,
            fhevmDecryptionSignatureStorage
          );

        if (!sig) {
          setMessage("Unable to build FHEVM decryption signature");
          return;
        }

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        setMessage("Call FHEVM userDecrypt...");

        const handlesToDecrypt: Array<{ handle: string; contractAddress: string }> = [];
        if (thisRequiredSavingHandle && thisRequiredSavingHandle !== ethers.ZeroHash) {
          handlesToDecrypt.push({ handle: thisRequiredSavingHandle, contractAddress: thisAddress });
        }
        if (thisAchievabilityHandle && thisAchievabilityHandle !== ethers.ZeroHash) {
          handlesToDecrypt.push({ handle: thisAchievabilityHandle, contractAddress: thisAddress });
        }

        if (handlesToDecrypt.length === 0) {
          setMessage("No handles to decrypt");
          return;
        }

        const res = await instance.userDecrypt(
          handlesToDecrypt,
          sig.privateKey,
          sig.publicKey,
          sig.signature,
          sig.contractAddresses,
          sig.userAddress,
          sig.startTimestamp,
          sig.durationDays
        );

        setMessage("FHEVM userDecrypt completed!");

        if (isStale()) {
          setMessage("Ignore FHEVM decryption");
          return;
        }

        const toBigIntOrUndefined = (v: string | bigint | boolean | undefined): bigint | undefined => {
          if (typeof v === "bigint") {
            return v;
          }
          if (typeof v === "string") {
            try {
              return BigInt(v);
            } catch {
              return undefined;
            }
          }
          return undefined;
        };

        type ClearValuePrimitive = string | bigint | boolean;
        type ClearValuesLike = Record<string, ClearValuePrimitive> | Map<string, ClearValuePrimitive>;

        const getClearByHandle = (
          results: ClearValuesLike | unknown,
          handle: string | undefined
        ): ClearValuePrimitive | undefined => {
          if (!results || !handle) return undefined;
          if (typeof (results as Map<string, ClearValuePrimitive>).get === "function") {
            return (results as Map<string, ClearValuePrimitive>).get(handle);
          }
          return (results as Record<string, ClearValuePrimitive>)[handle];
        };

        setDecryptedResults({
          requiredSaving: toBigIntOrUndefined(getClearByHandle(res as ClearValuesLike, thisRequiredSavingHandle)),
          achievability: toBigIntOrUndefined(getClearByHandle(res as ClearValuesLike, thisAchievabilityHandle)),
        });

        setMessage("Decryption completed successfully!");
      } finally {
        isDecryptingRef.current = false;
        setIsDecrypting(false);
      }
    };

    run();
  }, [
    fhevmDecryptionSignatureStorage,
    ethersSigner,
    savingPlanner.address,
    instance,
    requiredSavingHandle,
    achievabilityHandle,
    chainId,
    sameChain,
    sameSigner,
  ]);

  return {
    contractAddress: savingPlanner.address,
    canSubmit,
    canDecrypt,
    submitSavingsPlan,
    decryptResults,
    refreshData,
    message,
    decryptedResults,
    isSubmitting,
    isDecrypting,
    isRefreshing,
    isDeployed,
  };
};

